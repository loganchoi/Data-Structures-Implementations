// As always, DO NOT EDIT THIS FILE!
// Many of the functions will be simplified single-parameter versions of the
//  multiple std:: options (https://en.cppreference.com/w/cpp/container/unordered_map)
// Where they differ, we have made a brief note in these source files here 

#ifndef MYUNORDEREDMAP_H
#define MYUNORDEREDMAP_H

#include <iostream>
#include <stdexcept>
#include <string>
#include "Dictionary.h"

using std::cout;
using std::endl;

void get_identity(std::string &my_id);

template <typename K, typename V>
class MyUnorderedMap: public Dictionary<K, V>
{
    private:
        MyPair<K, V> *m_data = nullptr;

        int data_size = 0;
        int reserved_size = 0;

        // Remember the key value can be any type; but we'll only test with
        //  std::string keys
        // So, choose your hashing function that is the most appropriate for the
        //  key type that we are working with
        int hash(const K &key) const;

    public:
        // Should start out with data_size and reserved_size at 0, and
        //  m_data to nullptr
        MyUnorderedMap();

        ~MyUnorderedMap();

        MyUnorderedMap(const MyUnorderedMap<K, V> &source);

        MyUnorderedMap<K, V> & operator=(const MyUnorderedMap<K, V> &source);

        V & at(const K &key);

        // if key does not exist in the table, inserts a new element into the
        //  table with the value of key and returns a reference to its mapped
        //  value
        V & operator[](const K &key);

        bool empty() const;

        int size() const;

        // data_size and reserved_size should be 0 after this clear operation,
        //  and m_data should be nullptr.
        void clear();

        // note: duplicate keys are not allowed
        void insert(const MyPair<K, V> &init_pair);

        void erase(const K &key);

        // Should return nullptr for key not found in the hash table
        MyPair<K, V> * find(const K &key) const;

        // Not actually std::
        // For Hash table, just print all elements in any order,
        //  so that it looks like this when you print(unordereded_map_obj):
        //  ([K0]=V0,
        //   [K1]=V1,
        //   [K2]=V2)
        //  with a newline at the end like in sample_output.txt
        // Only print valid current data elements in the hash table
        void print() const;

        int count(const K &key) const;

        // Grows or shrinks reserved_size and the size of the dynamic array to
        //  be the new capcity of new_cap.
        // Other functions, like insert, erase, or [], should then be responsible
        //  of decideing when to grow or shrink.
        // Expansion rule: DOUBLE the reserved size when the HT becomes 60% full
        //  - this also means that during a new key insertion, there is always
        //      at least one open slot
        // COMPACTION rule: SHRINK the HT to 30% of the original capacity when
        //  it becomes 10% full
        // This is where RE-HASHING occurs
        void reserve(int new_cap);

};

// Should accept a source code file (sample_input.cpp for example) via std in
// Should build a dictionary of the counts of the words in the code file that
//  contain the word "virus" (not case sensitive ONLY during the checking)
// To further clarify, when inserted into the dictionary, similar words but
//  DIFFER in cases should be treated as two distinct keys
//  (e.g. CryptoLockerVirus vs cryptoLockerVirus)
// DO NOT include newlines (\n) to the dictionary (they'll mess up print)
// Most symbols should be excluded to isolate the actual keywords and variable
//  names in the code
// e.g. (CryptoLockerVirus) or *CryptoLockerVirus should be isolated to just
//  CryptoLockerVirus
void get_virus_frequency(MyUnorderedMap<std::string, int> &in_tree);


#include "MyUnorderedMap.hpp"

#endif
